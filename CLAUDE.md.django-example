# CLAUDE.md - Content Management API

**Configuration Status**: PERMANENT
**Purpose**: Django REST API project specific conventions

## Absolute Rules - Project Priority Principle

### Rule Priority

**Important**: When project documentation conflicts with AI general knowledge, follow project documentation

Priority (High → Low):
1. Explicit project rules (CLAUDE.md, README.md) ← Highest Authority
2. Production code behavior (what actually exists)
3. AI general knowledge (Django, DRF, etc.) ← Lowest Authority

**Reason for this hierarchy**:
- This is a microservices architecture with custom service mesh integration
- Django REST Framework patterns customized for high-traffic API usage
- Team follows domain-driven design principles not typical in Django projects

---

## Multi-Repository Configuration

This project is part of a microservices content platform:

```
Content Platform/
├── content-api/        # Content management API (THIS REPOSITORY)
├── media-service/      # Media processing and storage
├── search-service/     # Elasticsearch integration
└── auth-service/       # Authentication and authorization

Shared Libraries/
├── common-models/      # Shared Django models
├── api-client/         # Internal API client library
└── event-bus/          # Event-driven communication
```

**Inter-Repository Dependencies**:
- content-api → depends on auth-service (authentication)
- content-api → publishes events to event-bus
- media-service → subscribes to content-api events
- search-service → subscribes to content-api events

**Production Code Verification Protocol**:
Before creating tests, verify code exists across services:
1. Check current repository
2. Search related microservices for shared logic
3. Check common-models for domain entities
4. Use production-verifier agent for cross-service search

---

## Project-Specific Standards

### Test Docstring Format (Required)

**This format is project-specific and MANDATORY**:

```python
def test_feature_name(self):
    """[Feature description in English - technical focus]

    Guarantees:
        1. [Specific guarantee - what breaks if this test fails]
        2. [Another specific guarantee]

    Business Impact:
        - [What happens to users/business if this fails]
        - [Additional impact with metrics if available]

    Related Issues: #123, #456
    """
```

**Why project-specific**:
- Product managers participate in code reviews
- Need to track test coverage against business requirements
- Post-incident analysis requires linking tests to user impact

**Example**:
```python
def test_bulk_content_publish_maintains_consistency(self):
    """Verify bulk publishing maintains referential integrity across services.

    Guarantees:
        1. All related media files are validated before content publish
        2. Failed media validation prevents content publish atomically
        3. Rollback occurs if event bus notification fails

    Business Impact:
        - Prevents publishing content with broken images (affects ~1000 users/day)
        - Maintains search index consistency (prevents 404 errors)
        - Avoids manual data cleanup (saves ~2 hours/incident)

    Related Issues: #2341, #2890
    """
```

**Enforcement**: Custom pytest plugin validates docstring format

---

### Django Settings Pattern

**Environment-Based Configuration**:

**Structure**:
```
config/
├── settings/
│   ├── base.py         # Shared settings
│   ├── development.py  # Local development
│   ├── staging.py      # Staging environment
│   ├── production.py   # Production environment
│   └── test.py         # Test-specific settings
```

**Why project-specific**:
- Support for 3 deployment environments (staging, production, DR)
- Each environment has different service endpoints
- Secrets managed via AWS Secrets Manager (not environment variables)

**Test Settings Rules**:

❌ **PROHIBITED**:
```python
# NEVER override Django settings mid-test
from django.conf import settings

def test_feature(self):
    settings.FEATURE_ENABLED = True  # ❌ WRONG
    # This pollutes other tests
```

✅ **REQUIRED**:
```python
# Use Django's settings override context manager
from django.test import override_settings

@override_settings(FEATURE_ENABLED=True)
def test_feature(self):
    # ✅ CORRECT - Isolated to this test
    pass
```

**Rationale**:
- Setting mutations leak between tests
- Historical incident: Test pollution caused 30-minute CI failure investigation

---

### API Versioning Standards

**URL Pattern**: `/api/v{version}/{resource}/`

**Supported Versions**: v1, v2

**Version Deprecation Process**:
1. Announce deprecation 6 months in advance
2. Add deprecation warnings to API responses
3. Monitor v1 usage metrics
4. Remove v1 only when usage < 1%

**Why project-specific**:
- Public API with external clients (can't force upgrades)
- Contractual SLA commitments to API stability
- Version-specific test suites required

**Testing Requirements**:
- Each API version has separate test directory
- Deprecated versions still require full test coverage
- Breaking changes require tests in BOTH versions

---

### Database Migration Strategy

**Migration Naming Convention**:
```
YYYY_MM_DD_HHMM_descriptive_name.py
```

**Example**: `2025_01_15_1430_add_content_status_index.py`

**Migration Rules**:
1. NEVER use `RunPython` for data migrations in production migrations
2. Data migrations go in separate `data_migrations/` directory
3. All migrations must be reversible (implement `reverse()`)
4. Schema changes must maintain backward compatibility for 2 releases

**Why project-specific**:
- Zero-downtime deployment requirement
- Database shared across 3 application instances
- Old and new code versions run simultaneously during deployment

**Testing Requirements**:
```python
def test_migration_forward_backward(self):
    """Verify migration can be applied and reversed without data loss.

    Guarantees:
        1. Migration applies successfully on production-like dataset
        2. Migration reversal restores original state
        3. No data loss during forward/backward cycle

    Business Impact:
        - Prevents deployment rollback failures (historical: 2 incidents/year)
        - Ensures zero-downtime deployment (99.95% SLA requirement)
    """
```

---

### Prohibited Patterns

#### 1. Synchronous External API Calls in Request Path (Prohibited)

❌ **PROHIBITED**:
```python
# NEVER make synchronous calls to external services in views
def create_content(request):
    content = Content.objects.create(...)
    media_service.upload_image(content.image)  # ❌ Blocks request
    search_service.index_content(content)      # ❌ Blocks request
    return Response(status=201)
```

✅ **REQUIRED**:
```python
# Use Celery tasks for external service calls
def create_content(request):
    content = Content.objects.create(...)
    upload_image_task.delay(content.id)         # ✅ Async
    index_content_task.delay(content.id)        # ✅ Async
    return Response(status=201)
```

**Reason**: P95 latency SLA is 200ms

---

#### 2. Raw SQL Queries Without Query Logging (Prohibited)

❌ **PROHIBITED**:
```python
# Raw SQL without performance tracking
cursor.execute("SELECT * FROM content WHERE ...")  # ❌
```

✅ **REQUIRED**:
```python
# Use ORM or log raw queries
from django.db import connection
from myapp.utils import log_query

with log_query("content_search"):
    cursor.execute("SELECT * FROM content WHERE ...")  # ✅
```

**Reason**: Need query performance metrics for database optimization

---

#### 3. Direct User Authentication in Tests (Prohibited)

❌ **PROHIBITED**:
```python
# NEVER bypass auth-service in tests
def test_protected_endpoint(self):
    user = User.objects.create(username='test')
    self.client.force_authenticate(user=user)  # ❌
```

✅ **REQUIRED**:
```python
# Mock auth-service responses
def test_protected_endpoint(self):
    with mock_auth_service(user_id=123, roles=['editor']):
        response = self.client.get('/api/v2/content/')  # ✅
```

**Reason**: Tests must verify actual auth integration logic

---

## Testing Standards

### Test Organization

```
tests/
├── unit/                   # Fast, isolated unit tests
│   ├── models/
│   ├── serializers/
│   └── utils/
├── integration/            # Database + service integration
│   ├── api/
│   └── tasks/
├── e2e/                    # End-to-end cross-service tests
│   └── workflows/
└── performance/            # Load and performance tests
    └── benchmarks/
```

**Test Execution Strategy**:
- Unit tests: Run on every commit (< 30 seconds)
- Integration tests: Run on every PR (< 5 minutes)
- E2E tests: Run on merge to main (< 15 minutes)
- Performance tests: Run nightly (< 1 hour)

---

### Fixture Management

**Prohibited**: Django fixtures (JSON/YAML)
**Required**: factory_boy factories

**Why**:
- Fixtures break when models change
- Factories generate only needed data
- Better test readability

**Example**:
```python
# tests/factories.py
import factory

class ContentFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = Content

    title = factory.Faker('sentence')
    author = factory.SubFactory(UserFactory)
    status = 'draft'

# Usage in tests
def test_publish_content(self):
    content = ContentFactory(status='draft')  # ✅
    # Not: loading 100KB fixture JSON
```

---

### Mocking External Services

**Required Pattern**: Use `responses` library for HTTP mocking

```python
import responses

@responses.activate
def test_media_service_integration(self):
    # Mock media-service response
    responses.add(
        responses.POST,
        'https://media-service/api/upload',
        json={'id': '123', 'url': 'https://cdn/image.jpg'},
        status=200
    )

    # Test code that calls media-service
    result = upload_to_media_service(image_data)
    assert result['id'] == '123'
```

**Why project-specific**:
- Standardizes mocking across team
- Makes test failures easier to debug
- Prevents flaky tests from network issues

---

## Custom Approval Workflow

All code changes require:

1. **Automated Checks** (Must Pass)
   - pytest (all test categories for PR)
   - ruff (linting)
   - mypy (type checking)
   - Coverage ≥ 85%

2. **Code Review** (2 approvals required)
   - Senior developer approval
   - Domain expert approval (for business logic changes)

3. **API Contract Review** (for API changes)
   - API breaking changes require API owner approval
   - OpenAPI spec updated
   - Client SDK updated (if applicable)

---

## Quality Gates

Before merge to main, ALL must pass:

- [ ] pytest coverage ≥ 85%
- [ ] No mypy type errors
- [ ] ruff linting passes
- [ ] Test docstrings in required format
- [ ] API version compatibility verified
- [ ] Database migration is reversible
- [ ] Performance tests pass (if touching critical path)
- [ ] OpenAPI spec updated (if API changed)

---

## Performance Requirements

### API Latency SLAs

| Endpoint Type | P50 | P95 | P99 |
|---------------|-----|-----|-----|
| GET (list) | 50ms | 150ms | 300ms |
| GET (detail) | 30ms | 100ms | 200ms |
| POST/PUT | 100ms | 200ms | 400ms |
| DELETE | 50ms | 150ms | 300ms |

**Testing**: Performance tests in `tests/performance/` verify SLA compliance

**Why project-specific**:
- Contractual SLA with enterprise clients
- Financial penalties for SLA violations
- Performance regression has direct revenue impact

---

## Emergency Response Protocol

**When**: Production API outage or data corruption

**Severity Levels**:
- **P0**: Complete service down → Page on-call engineer immediately
- **P1**: Degraded performance → Notify on-call within 15 minutes
- **P2**: Minor issue → Create ticket, fix in next sprint

**Process for P0**:
1. Rollback deployment immediately
2. Post-incident analysis within 24 hours
3. Root cause documented in `.work/issue-solutions.yaml`
4. Prevention measures added to test suite
5. Update CLAUDE.md if new pattern identified

---

## Historical Context

**Project Age**: 3 years
**Team Size**: 12 developers (4 teams)
**API Traffic**: 10M requests/day
**Uptime SLA**: 99.95%

**Why These Rules Exist**:
These standards evolved from production incidents:
- Async external calls → After timeout caused 15-minute outage
- Migration reversibility → After failed deployment required database restore
- Auth mocking prohibition → After auth integration bug reached production
- Test docstring format → After P0 incident with no related test coverage

---

## Maintenance

**Review Frequency**: Quarterly
**Next Review**: 2025-Q2
**Owner**: API Platform Team Lead (@platform-lead)

**Changelog**:
- 2025-01-15: Added performance SLA requirements
- 2024-11-01: Strengthened migration testing requirements
- 2024-08-15: Added API versioning deprecation process
- 2024-06-01: Introduced test docstring format standard
